\htmlhr
\section{Nullness checker\label{nullness-checker}}

If the Nullness checker issues no warnings for a given program, then
running that program will never throw a null pointer exception.  This
guarantee enables a programmer to prevent errors from occurring when his
program is run.  See Section~\ref{nullness-checks} for more details about
the guarantee and what is checked.


% Should some/all of this be moved into the flow-sensitive section, or a
% general section about all the checkers?
You can control the behavior of the Nullness checker via the \code{-Alint}
options \code{flow}, \code{cast}, and \code{cast:redundant}.



\subsection{Nullness annotations}

The Nullness checker uses two separate type hierarchies:  one for nullness,
and one for rawness (see Section~\ref{raw-partially-initialized}).

The nullness hierarchy contains these qualifiers:

\begin{description}

\item[\code{@\refclass{nullness/quals}{Nullable}}]
  indicates a type that includes the null value.  The type \code{Boolean}
  is nullable; a variable of type \code{Boolean} always has one of the
  values \code{TRUE}, \code{FALSE}, or \code{null}.

\item[\code{@\refclass{nullness/quals}{NonNull}}]
  indicates a type that does not include the null value.  The type
  \code{boolean} is non-null; a variable of type \code{boolean} always has
  one of the values \code{true} or \code{false}.  The type \code{@NonNull
    Boolean} is also non-null:  a variable of type \code{@NonNull Boolean}
  always has one of the values \code{TRUE} or \code{FALSE} --- never
  \code{null}.  Dereferencing an expression of non-null type can never cause
  a null pointer exception.
  Furthermore, the object referenced by a \<@NonNull> type is always fully
  initialized --- that is, its \<@NonNull> fields have been set to a
  non-null value.

\item[\code{@\refclass{nullness/quals}{PolyNull}}]
  indicates qualifier polymorphism.  For a description of
  \<@\refclass{nullness/quals}{PolyNull}>, see
  Section~\ref{qualifier-polymorphism}.

\item[\code{@\refclass{nullness/quals}{LazyNonNull}}]
  indicates a reference that may be \code{null}, but if it ever becomes
  non-\code{null}, then it never becomes \code{null} again.  This is
  appropriate for lazily-initialized fields, among other uses.  When the
  variable is read, its type is treated as
  \code{@\refclass{nullness/quals}{Nullable}}, but when the variable is
  assigned, its type is treated as
  \code{@\refclass{nullness/quals}{NonNull}}.

  Because the Nullness checker works intraprocedurally (it analyzes one
  method at a time), when a \code{LazyNonNull} field is first read within a
  method, the field cannot be assumed to be non-null.  The benefit of
  LazyNonNull over Nullable is its different interaction with
  flow-sensitive type qualifier refinement.  After a check of a LazyNonNull
  field, all subsequent accesses \emph{within that method} can be assumed
  to be NonNull, even after arbitrary external method calls that have
  access to the given field.

\end{description}

Figure~\ref{fig:nonnull-hierarchy} shows part of the type hierarchy for the
Nullness type system.


\begin{figure}
\begin{center}
\resizebox{!}{2.5cm}{\includegraphics{figures/nullness}}
\end{center}
%BEGIN LATEX
\vspace{-1.5\baselineskip}
%END LATEX
\caption{Partial type hierarchy for the Nullness type system.
Java's \<Object> is expressed as \<@Nullable Object>.  Programmers can omit
most type qualifiers, because the default annotation
(Section~\ref{null-defaults}) is usually correct.}
\label{fig:nonnull-hierarchy}
\end{figure}


\subsubsection{\code{@Raw} annotation for partially-initialized objects\label{raw-partially-initialized}}

The rawness hierarchy contains these qualifiers:

\begin{description}

\item[\code{@\refclass{nullness/quals}{Raw}}]
  indicates a type that contains a partially-initialized object.  In a
  partially-initialized object, fields that are annotated as
  \code{@\refclass{nullness/quals}{NonNull}} may be null because the field
  has not yet been assigned.  Within the constructor,
  \code{this} has \code{@\refclass{nullness/quals}{Raw}} type.

% Cut this?
\item[\code{@\refclass{nullness/quals}{NonRaw}}]
  indicates a type that contains a fully-initialized object.  \code{NonRaw}
  is the default, so there is little need for a programmer to write this
  explicitly.

\item[\code{@\refclass{nullness/quals}{PolyRaw}}]
  indicates qualifier polymorphism over rawness (see
  Section~\ref{qualifier-polymorphism}).

\end{description}

During execution of a constructor, every field of non-primitive type starts
out with the value \code{null}.  If the field has
\code{@\refclass{nullness/quals}{NonNull}} type, its initial value \code{null}
violates the \code{@NonNull} type qualifier.  In other words, during
construction, the object is in an illegal state.

% However, if the constructor makes
% a method call (passing \code{this} as a parameter or the receiver), then
% the called method could observe the object in an illegal state.

The \code{@\refclass{nullness/quals}{Raw}} type annotation represents a
partially-initialized object.  If a reference has
\code{@Raw} type, then all of its fields are treated as
\code{@\refclass{nullness/quals}{LazyNonNull}}:  when read, they are
treated as being \code{@\refclass{nullness/quals}{Nullable}}, but when
written, they are treated as being
\code{@\refclass{nullness/quals}{NonNull}}.


% Does our implementation handle static fields soundly?


\paragraph{How an object becomes non-raw}

The Nullness checker issues an error if the constructor fails to initialize
any non-null field.  This ensures that the object is in a legal (non-raw)
state by the time that the constructor exits.
% Java does not require that fields are definitely 
\urldef{\jlsdefiniteassignmenturl}{\url}{http://java.sun.com/docs/books/jls/third_edition/html/defAssign.html}
This is different than Java's test for definite assignment  (see 
\ahref{\jlsdefiniteassignmenturl}{JLS ch.16}),
% , which requires that local
% variables (and blank \code{final} fields) must be assigned.  Java does not
% require that non-\code{final} fields be assigned, since 
which does not apply to apply to fields because fields have a default value
of null.


Within the constructor,
\code{this} has \code{@\refclass{nullness/quals}{Raw}} type.
As soon as all of the \code{@\refclass{nullness/quals}{NonNull}} fields
have been initialized, then \code{this} is treated as non-raw.

% and can only be passed to methods when the corresponding parameter is
% annotated with \code{@\refclass{nullness/quals}{Raw}}.  Similar
% restrictions apply to assigning \code{this} to a field.

Suppose that class C extends class B, which extends class A.  Within the C
constructor, until the superclass constructor is called, \code{this} has
type \code{@Raw C} and also \code{@Raw B} and \code{@Raw A}.  After the
superclass constructor has been called, then \code{this} has type
\code{@Raw C} and also \code{@NonRaw B} and \code{@NonRaw A}.
% \urldef{\jlsconstructorbodyurl}{\url}{http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.8.7}
% (Recall that the superclass constructor is called on the first line, or is
% inserted automatically by the compiler before the first line, see 
% \ahref{\jlsconstructorbodyurl}{JLS \S8.8.7}.)



% Should we change the terminology?
\paragraph{A note about the terminology ``raw''}

The name ``raw'' comes from a research paper that proposed this
approach~\cite{FahndrichL2003}.  The \code{@\refclass{nullness/quals}{Raw}}
annotation has nothing to do with the raw types of Java Generics.



\subsection{Writing nullness annotations\label{writing-nullness-annotations}}

\subsubsection{Implicit qualifiers}

As described in Section~\ref{effective-qualifier}, the Nullness checker
adds implicit qualifiers, reducing the number of annotations that must
appear in your code.
For example, enum types are implicitly non-null, so you never need to write
\<@NonNull MyEnumType>.

For a complete description of all implicit nullness qualifiers, see the
Javadoc for \refclass{nullness}{NullnessAnnotatedTypeFactory}.



\subsubsection{Default annotation\label{null-defaults}}

Unannotated references are treated as if they had a default annotation,
using the NNEL (non-null except locals) rule described below.
A user may choose a different rule for defaults using the 
\code{@\refclass{quals}{DefaultQualifier}} annotation; see
Section~\ref{defaults}.

\begin{sloppy}
Here are three possible default rules you may wish to use.  Other rules are
possible but are not as useful.
\begin{itemize}
\item
  \code{@\refclass{nullness/quals}{Nullable}}:  Unannotated types are regarded as possibly-null, or
  nullable.  This default is backward-compatible with Java, which permits
  any reference to be null.  You can activate this default by writing
  a \code{@DefaultQualifier("checkers.nullness.quals.Nullable")} annotation on a
  % package/
  class or method
  % /variable
  declaration.
\item
  \code{@\refclass{nullness/quals}{NonNull}}:  Unannotated types are treated as non-null.
  % This may leads to fewer annotations written in your code.
  You can activate this
  default via the
  \code{@DefaultQualifier("checkers.nullness.quals.NonNull")} annotation.
\item
  Non-null except locals (NNEL):  Unannotated types are treated as
  \code{@\refclass{nullness/quals}{NonNull}}, \emph{except} that the unannotated raw type of a local
  variable is treated as \code{@\refclass{nullness/quals}{Nullable}}.  (Any generic arguments to a
  local variable still default to \code{@\refclass{nullness/quals}{NonNull}}.)  You can activate this
  default via the \code{@DefaultQualifier(value="checkers.nullness.quals.NonNull",
    locations=\discretionary{}{}{}\{DefaultLocation\discretionary{}{}{}.ALL\_EXCEPT\_LOCALS\})} annotation.

  The NNEL default leads to the smallest number of explicit annotations in
  your code~\cite{PapiACPE2008}.  It is what we recommend.  If you do not
  explicitly specify a different default, then NNEL is the default.
\end{itemize}
\end{sloppy}



\subsubsection{Inference of \code{@NonNull} and \code{@Nullable} annotations\label{nullness-inference}}

It can be tedious to write annotations in your code.  Two tools exist that
can automatically infer annotations and insert them in your source code.
(This is different than type qualifier refinement for local variables
(Section~\ref{type-refinement}), which infers a more specific type for
local variables and uses them during type-checking but does not insert them
in your source code.  Type qualifier refinement is always enabled, no
matter how annotations on signatures got inserted in your source code.)

Your choice of tool depends on what default annotation (see
Section~\ref{null-defaults}) your code uses.  You only need one of these tools.

\begin{itemize}

\item
  Inference of \code{@\refclass{nullness/quals}{Nullable}}:
  %
  If your code uses the standard NNEL (non-null-except-locals) default or
  the \refclass{nullness/quals}{NonNull} default, then use the
  \ahref{http://groups.csail.mit.edu/pag/daikon/download/doc/daikon.html#AnnotateNullable}{AnnotateNullable}
  tool of the \ahref{http://pag.csail.mit.edu/daikon/}{Daikon invariant
    detector}.

\item
  Inference of \code{@\refclass{nullness/quals}{NonNull}}:
  % 
  If your code uses the Nullable default, use the
  \ahref{http://jastadd.org/jastadd-tutorial-examples/non-null-types-for-java}{Non-null
    checker and inferencer} of the \ahref{http://jastadd.org/}{JastAdd
    Extensible Compiler}.

\end{itemize}




\subsection{What the Nullness checker checks\label{nullness-checks}}

The checker issues a warning in two cases:

\begin{enumerate}

\item
  When an expression of non-\code{@\refclass{nullness/quals}{NonNull}} type
  is dereferenced, because it might cause a null pointer exception.
  Dereferences occur not only when a field is accessed, but when an array
  is indexed, an exception is caught, a lock is taken in a synchronized
  block, and more.  For a complete description of all checks performed by
  the Nullness checker, see the Javadoc for
  \refclass{nullness}{NullnessVisitor}.

\item
  When an expression of \code{@\refclass{nullness/quals}{NonNull}} type might become null, because it
  is a misuse of the type:  the null value could flow to a dereference that
  the checker does not warn about.

\end{enumerate}

This example shows both sorts of problems:

\begin{Verbatim}
           Object   obj;  // might be null
  @NonNull Object nnobj;  // never null
  ...
    obj.toString()  // checker warning:  dereference might cause null pointer exception
  nnobj = obj;      // checker warning:  nnobj may become null
\end{Verbatim}

Parameter passing and return values are checked analogously to assignments.



\subsubsection{Suppressing warnings with assertions\label{suppressing-warnings-with-assertions}}

In addition to the other ways of suppressing warnings
(Section~\ref{suppressing-warnings}), the Nullness checker 
assumes that assertions succeed.  For example, it assumes that no null
pointer exception can occur in code such as
\begin{Verbatim}
assert x != null;
... x.f ...
\end{Verbatim}

(Another way of stating the Nullness checker's use of assertions is as an
additional caveat to the guarantees provided by a checker
(Section~\ref{checker-guarantees}).  The Nullness checker prevents null
pointer errors in your code under the assumption that assertions are
enabled, and it does not guarantee that all of your assertions succeed.)



\subsection{Examples\label{nullness-example}}

\subsubsection{Tiny examples\label{nullness-tiny-examples}}

To try the Nullness checker on a source file that uses the \code{@\refclass{nullness/quals}{NonNull}} qualifier,
use the following command (where \code{javac} is the JSR 308 compiler that
is distributed with the Checker Framework):

\begin{Verbatim}
  javac -processor checkers.nullness.NullnessChecker examples/NullnessExample.java
\end{Verbatim}

\noindent
Compilation will complete without warnings.

To see the checker warn about incorrect usage of annotations (and therefore the
possibility of a null pointer exception at run time), use the following command:

\begin{Verbatim}
  javac -processor checkers.nullness.NullnessChecker examples/NullnessExampleWithWarnings.java
\end{Verbatim}

\noindent
The compiler will issue three warnings regarding violation of the semantics of
\code{@\refclass{nullness/quals}{NonNull}}.
% in the \code{NonNullExampleWithWarnings.java} file.


\subsubsection{Annotated library\label{nullness-annotated-library}}

Three libraries that or annotated with nullness qualifiers are:

\begin{itemize}
\item
The Nullness checker itself.

\item
The 
\ahref{http://groups.csail.mit.edu/pag/daikon/}{Daikon invariant detector}.
Run the command \code{make check-nullness}.

\item
The annotation scene library.
To run the Nullness checker on the annotation scene library,
% TODO: how does one do this?
first download the scene library suite (which includes build
dependencies for the scene library as well as its source code) and extract it
into your checkers installation. The checker can then be run on the annotation
scene library with Apache Ant using the following commands:

\begin{Verbatim}
  cd checkers
  ant -f scene-lib-test.xml
\end{Verbatim}

% \noindent
% where \code{checkers} is the location of the Checker Framework installation.

You can view the annotated source code, which contains \code{@\refclass{nullness/quals}{NonNull}} annotations, in
the
%BEGIN LATEX
\begin{smaller}
%END LATEX
\code{checkers/scene-lib-test/src/annotations/}
%BEGIN LATEX
\end{smaller}
%END LATEX
directory.

\end{itemize}


\subsection{Other tools for nullness checking\label{nullness-related-work}}

The Checker Framework \code{@\refclass{nullness/quals}{NonNull}} annotation is similar, but not
identical, to the \code{@NotNull} annotation of IntelliJ IDEA, the
\code{@NonNull} annotation of FindBugs, the \code{non\_null} modifier of
JML, and annotations proposed by JSR 305, among others.
Also see Section~\ref{other-tools} for a comparison to other tools.


% LocalWords:  NonNull plugin quals un NonNullExampleWithWarnings java ahndrich
% LocalWords:  NotNull IntelliJ FindBugs Nullable TODO Alint nullable NNEL JSR
% LocalWords:  DefaultLocation Nullness PolyNull nullness AnnotateNullable JLS
% LocalWords:  Daikon JastAdd javac DefaultQualifier boolean MyEnumType NonRaw
% LocalWords:  NullnessAnnotatedTypeFactory NullnessVisitor LazyNonNull PolyRaw
% LocalWords:  inferencer utilMDE
